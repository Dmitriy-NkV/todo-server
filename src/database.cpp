#include "database.hpp"

database::Task::Task(int id, std::string title, std::string description, std::string status, std::chrono::system_clock::time_point created_at):
  id_(id),
  title_(title),
  description_(description),
  status_(status),
  created_at_(created_at)
{}

std::optional< int > database::Task::get_id() const
{
  return id_;
}

std::optional< std::string > database::Task::get_title() const
{
  return title_;
}

std::optional< std::string > database::Task::get_description() const
{
  return description_;
}

std::optional< std::string > database::Task::get_status() const
{
  return status_;
}

std::chrono::system_clock::time_point database::Task::get_created_at() const
{
  return created_at_;
}

void database::to_json(nlohmann::json& j, const Task& t)
{
  j = nlohmann::json{
    { "id", (*t.id_) },
    { "title", t.title_ },
    { "description", t.description_ },
    { "status", t.status_ },
    { "created_at", t.created_at_ }
  };
}

void database::from_json(const nlohmann::json& j, Task& t)
{
  database::Task task;
  if (j.contains("id"))
  {
    task.id_ = j["id"];
  }
  if (j.contains("title"))
  {
    task.id_ = j["title"];
  }
  if (j.contains("description"))
  {
    task.id_ = j["description"];
  }
  if (j.contains("status"))
  {
    task.id_ = j["status"];
  }
  if (j.contains("created_at"))
  {
    task.created_at_ = j["created_at"];
  }
  else
  {
    task.created_at_ = std::chrono::system_clock::now();
  }
}

database::Database::Database(const std::string& connection_string):
  connection_string_(connection_string),
  connection_(PQconnectdb(connection_string_.c_str()))
{
  if (PQstatus(connection_) != CONNECTION_OK)
  {
    std::string error = PQerrorMessage(connection_);
    PQfinish(connection_);
    connection_ = nullptr;
    throw std::logic_error(error);
  }
}

database::Database::~Database()
{
  PQfinish(connection_);
}

void database::Database::initialize_database()
{
  std::string check_table_query = R"(
    SELECT EXISTS (
      SELECT 1 FROM information_schema.tables 
      WHERE table_schema = 'public'
      AND table_name = 'tasks'
    )
  )";

  PGresult* res = PQexec(connection_, check_table_query.c_str());
  if (PQresultStatus(res) != PGRES_TUPLES_OK)
  {
    std::string error = PQerrorMessage(connection_);
    PQclear(res);
    throw std::logic_error(error);
  }

  if (strcmp(PQgetvalue(res, 0, 0), "t") == 0)
  {
    PQclear(res);
    return;
  }

  std::string create_table_query = R"(
    CREATE TABLE tasks (
      id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      title VARCHAR(255) NOT NULL,
      description TEXT,
      status VARCHAR(50) NOT NULL,
      created_at BIGINT NOT NULL
    )
  )";

  res = PQexec(connection_, create_table_query.c_str());
  if (PQresultStatus(res) != PGRES_COMMAND_OK)
  {
    std::string error = PQerrorMessage(connection_);
    PQclear(res);
    throw std::logic_error(error);
  }

  PQclear(res);
}

void database::Database::create_task(const Task& task)
{
  std::string create_task_query = R"(
    INSERT INTO tasks (
      "title",
      "description",
      "status",
      "created_at"
    )
    VALUES (
      $1,
      $2,
      $3,
      $4
    )
  )";

  std::vector< const char* > params;
  params.push_back(task.get_title().value().c_str());
  params.push_back(task.get_description().value().c_str());
  params.push_back(task.get_status().value().c_str());
  params.push_back(std::to_string(std::chrono::duration_cast< std::chrono::seconds >(task.get_created_at().time_since_epoch()).count()).c_str());

  PGresult* res = PQexecParams(connection_, create_task_query.c_str(), params.size(), NULL, params.data(), NULL, NULL, 0);
  if (PQresultStatus(res) != PGRES_TUPLES_OK)
  {
    std::string error = PQerrorMessage(connection_);
    PQclear(res);
    throw std::logic_error(error);
  }
  PQclear(res);
}

void database::Database::delete_task(const Task& task)
{
  std::string delete_task_query = R"(
    DELETE FROM tasks
    WHERE id = $1
  )";

  std::vector< const char* > params;
  params.push_back(std::to_string(task.get_id().value()).c_str());

  PGresult* res = PQexecParams(connection_, delete_task_query.c_str(), params.size(), NULL, params.data(), NULL, NULL, 0);
  if (PQresultStatus(res) != PGRES_TUPLES_OK)
  {
    std::string error = PQerrorMessage(connection_);
    PQclear(res);
    throw std::logic_error(error);
  }
  PQclear(res);
}
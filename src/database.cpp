#include "database.hpp"

database::Task::Task(int id, std::string title, std::string description, std::string status, std::chrono::system_clock::time_point created_at):
  id_(id),
  title_(title),
  description_(description),
  status_(status),
  created_at_(created_at)
{}

std::optional< int > database::Task::get_id() const
{
  return id_;
}

std::optional< std::string > database::Task::get_title() const
{
  return title_;
}

std::optional< std::string > database::Task::get_description() const
{
  return description_;
}

std::optional< std::string > database::Task::get_status() const
{
  return status_;
}

std::chrono::system_clock::time_point database::Task::get_created_at() const
{
  return created_at_;
}

void database::to_json(nlohmann::json& j, const Task& t)
{
  j = nlohmann::json{
    { "id", t.id_.value() },
    { "title", t.title_.value() },
    { "description", t.description_.value() },
    { "status", t.status_.value() },
    { "created_at", t.created_at_ }
  };
}

void database::from_json(const nlohmann::json& j, Task& t)
{
  if (j.contains("id"))
  {
    t.id_ = j["id"];
  }
  if (j.contains("title"))
  {
    t.title_ = j["title"];
  }
  if (j.contains("description"))
  {
    t.description_ = j["description"];
  }
  if (j.contains("status"))
  {
    t.status_ = j["status"];
  }
  if (j.contains("created_at"))
  {
    t.created_at_ = j["created_at"];
  }
  else
  {
    t.created_at_ = std::chrono::system_clock::now();
  }
}

database::Database::Database(const std::string& connection_string):
  connection_string_(connection_string),
  connection_(PQconnectdb(connection_string_.c_str()))
{
  if (PQstatus(connection_) != CONNECTION_OK)
  {
    std::string error = PQerrorMessage(connection_);
    PQfinish(connection_);
    connection_ = nullptr;
    throw std::logic_error(error);
  }
}

database::Database::~Database()
{
  if (connection_ != nullptr)
  {
    PQfinish(connection_);
  }
}

void database::Database::initialize_database()
{
  std::lock_guard< std::mutex > lock(db_mutex_);
  std::string check_table_query = R"(
    SELECT EXISTS (
      SELECT 1 FROM information_schema.tables 
      WHERE table_schema = 'public'
      AND table_name = 'tasks'
    )
  )";

  PGresult* res = execute_query(check_table_query, {});

  if (strcmp(PQgetvalue(res, 0, 0), "t") == 0)
  {
    PQclear(res);
    return;
  }

  std::string create_table_query = R"(
    CREATE TABLE tasks (
      id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      title VARCHAR(255) NOT NULL,
      description TEXT,
      status VARCHAR(50) NOT NULL,
      created_at BIGINT NOT NULL
    )
  )";

  res = execute_query(create_table_query, {});

  PQclear(res);
}

void database::Database::create_task(const Task& task)
{
  std::lock_guard< std::mutex > lock(db_mutex_);
  std::string create_task_query = R"(
    INSERT INTO tasks (
      "title",
      "description",
      "status",
      "created_at"
    )
    VALUES (
      $1,
      $2,
      $3,
      $4
    )
  )";

  std::vector< const char* > params;
  params.push_back(task.get_title().value().c_str());
  params.push_back(task.get_description().value().c_str());
  params.push_back(task.get_status().value().c_str());
  params.push_back(std::to_string(std::chrono::duration_cast< std::chrono::seconds >(task.get_created_at().time_since_epoch()).count()).c_str());

  PGresult* res = execute_query(create_task_query, params);
  PQclear(res);
}

std::vector< database::Task > database::Database::get_all_tasks()
{
  std::lock_guard< std::mutex > lock(db_mutex_);
  std::string get_tasks_query = R"(
    SELECT id, title, description, status, created_at FROM tasks
  )";

  PGresult* res = execute_query(get_tasks_query, {});

  std::vector< database::Task > tasks;

  for (size_t i = 0; i != PQntuples(res); ++i)
  {
    tasks.push_back(result_to_task(res, i));
  }

  PQclear(res);
  return tasks;
}

std::optional< database::Task > database::Database::get_task_by_id(const Task& task)
{
  std::lock_guard< std::mutex > lock(db_mutex_);
  std::string get_task_query = R"(
    SELECT id, title, description, status, created_at FROM tasks
    WHERE id = $1
  )";

  std::vector< const char* > params;
  params.push_back(std::to_string(task.get_id().value()).c_str());

  PGresult* res = execute_query(get_task_query, params);

  if (PQntuples(res) == 0)
  {
    PQclear(res);
    return std::nullopt;
  }

  Task task = result_to_task(res, 0);

  PQclear(res);
  return task;
}

void database::Database::update_task(const Task& task)
{
  std::lock_guard< std::mutex > lock(db_mutex_);
  std::vector< const char* > params;
  std::vector< std::string > setParams;
  size_t paramIndex = 1;
  if (task.get_title() != std::nullopt)
  {
    params.push_back(task.get_title().value().c_str());
    setParams.push_back("title = $" + std::to_string(paramIndex++));
  }

  if (task.get_description() != std::nullopt)
  {
    params.push_back(task.get_description().value().c_str());
    setParams.push_back("description = $" + std::to_string(paramIndex++));
  }

  if (task.get_status() != std::nullopt)
  {
    params.push_back(task.get_status().value().c_str());
    setParams.push_back("status = $" + std::to_string(paramIndex++));
  }

  if (paramIndex == 1)
  {
    return;
  }

  params.push_back(std::to_string(task.get_id().value()).c_str());

  std::string update_task_query = "UPDATE tasks SET ";
  for (size_t i = 0; i != setParams.size(); ++i)
  {
    if (i != 0)
    {
      update_task_query += ", ";
    }
    update_task_query += setParams[i];
  }
  update_task_query += " WHERE id = $" + std::to_string(paramIndex);

  PGresult* res = execute_query(update_task_query, params);
  PQclear(res);
}

void database::Database::delete_task(const Task& task)
{
  std::lock_guard< std::mutex > lock(db_mutex_);
  std::string delete_task_query = R"(
    DELETE FROM tasks
    WHERE id = $1
  )";

  std::vector< const char* > params;
  params.push_back(std::to_string(task.get_id().value()).c_str());

  PGresult* res = execute_query(delete_task_query, params);
  PQclear(res);
}

PGresult* database::Database::execute_query(const std::string& query, const std::vector< const char* >& params)
{
  PGresult* res = PQexecParams(connection_, query.c_str(), params.size(), NULL, params.data(), NULL, NULL, 0);
  if (PQresultStatus(res) != PGRES_TUPLES_OK)
  {
    std::string error = PQerrorMessage(connection_);
    PQclear(res);
    throw std::logic_error(error);
  }
  return res;
}

database::Task database::Database::result_to_task(const PGresult* res, size_t row)
{
  int id = std::stoi(PQgetvalue(res, row, 0));
  std::string title = PQgetvalue(res, row, 1);
  std::string description = PQgetvalue(res, row, 2);
  std::string status = PQgetvalue(res, row, 3);
  std::chrono::system_clock::time_point created_at = std::chrono::system_clock::time_point(std::chrono::seconds(std::stoll(PQgetvalue(res, row, 4))));

  return Task(id, title, description, status, created_at);
}
